# Page 1

This guide shows you how to write a Solana program that creates compressed accounts.

```
Compressed Account Creation Flow
│
├─ CLIENT
│  ├─ 1. Generate instruction with proof and data
│  │  ├─ ValidityProof (getValidityProof() RPC)
│  │  ├─ PackedAddressTreeInfo
│  │  ├─ output_state_tree_index
│  │  └─ Custom data (message)
│  │
│  └─ 2. Send transaction to program
│
├─ YOUR PROGRAM
│  ├─ 1. Derive address
│  │
│  ├─ 2. Initialize Compressed Account Data
│  │
│  └─ 3. Light System Program CPI
      ├─ Verify proof (proves address does not exist yet) 
      └─ Create Compressed Account in State Tree
```

**Compressed Account Creation Flow**

The client

1. creates [instruction with proof and data](#user-content-fn-1)[^1]
2. then sends transaction to your program. Learn here how to call your program from a client.

Your program

1. derives a address and
2. performs a CPI from your custom program to the Light System program

The Light System program creates the compressed account.

{% hint style="success" %}
Your program calls the Light System program to create compressed accounts via CPI, similar to the System program to create regular accounts.
{% endhint %}

## Get Started

Use the `light-sdk` to create compressed accounts in three implementation steps:&#x20;

1. derive address,
2. compressed account initialization, and
3. cross-program invocation.&#x20;

The guide below covers each phase with detailed parameter explanations and implementation requirements.

{% stepper %}
{% step %}
### Dependencies

Set up `light-sdk` dependencies.

```toml
[dependencies]
light-sdk = "0.13.0"
borsh = "0.10.0"
```
{% endstep %}

{% step %}
### Constants

Set program address and CPI authority to call Light System program.

```rust
declare_id!("PROGRAM_ID");

pub const LIGHT_CPI_SIGNER: CpiSigner =
    derive_light_cpi_signer!("PROGRAM_ID");
```

**`Program_ID`**: The on-chain address of your program to derive address.

**`CPISigner`**: Configuration struct for CPI's to Light System Program. Contains your program ID, the derived CPI authority PDA, and PDA bump.
{% endstep %}

{% step %}
### Account Data Structure

Define your compressed account struct:

```rust
#[derive(
    Clone, 
    Debug, 
    Default, 
    BorshSerialize, // AnchorSerialize
    BorshDeserialize, // AnchorDeserialize 
    LightHasher, 
    LightDiscriminator
)]
pub struct DataAccount {
    #[hash]
    pub owner: Pubkey,
    #[hash]
    pub message: String,
}
```

`DataAccount` defines your account's data structure.

* `#[hash]` fields define the what's included in the compressed account hash.
* Changing any `#[hash]` field creates a new account hash. Requires creating a new compressed account via CPI with validity proof. Old hash becomes invalid.
* Non-`#[hash]` fields can be updated without creating new accounts

Compression Derives:

* `LightHasher` generates compressed account hash from `DataAccount`.
* `LightDiscriminator` gives struct unique type ID for deserialization. Required to distinguish `DataAccount` from other compressed account types.
{% endstep %}

{% step %}
### Instruction Data for `create_compressed_account`

The `create_compressed_account` instruction requires the following inputs:

```rust
pub struct InstructionData {
            proof: ValidityProof,
            address_tree_info: PackedAddressTreeInfo,
            output_state_tree_index: u8,
            message: String,
}
```

The transaction interacts with two Merkle trees. Both are maintained by the protocol

* **Address trees** are used to derive and store addresses for compressed accounts.
  * An address derived from a specified address tree is unique within that tree. Multiple address trees exist, and the same address seeds can be reused across different trees.
  * _uniqueness check_
  * If your program requires addresses to identify accounts but not uniqueness over all address trees, the used address Merkle tree does not need to be checked.
* **State trees** store compressed account hashes and are fungible.

{% hint style="info" %}
You can specify any Merkle tree listed in [_Addresses_](../../../resources/addresses-and-urls.md)_._
{% endhint %}

**Parameters:**

* `ValidityProof`: A zero-knowledge proof that validates non-inclusion of an address in the specified address tree. It's generated by the client via `getValidityProof()` with empty input accounts array.
* `PackedAddressTreeInfo`: Specifies pubkey of address tree to derive the adress with `derive_address()`. Ensure client and program reference the same address tree.
* `output_state_tree_index`: Specifies which state tree will store the compressed account hash and its index (`u8`). State trees are fungible - find their addresses [here](../../../resources/addresses-and-urls.md).
{% endstep %}

{% step %}
### Derive Address

Derive the compressed account address with the same parameters the client used for proof generation:

<pre class="language-rust"><code class="lang-rust">let address_merkle_tree_pubkey =
    address_tree_info.get_tree_pubkey(&#x26;light_cpi_accounts)?;
let custom_seeds = [SEED, ctx.accounts.signer.key().as_ref()];
let program_id = crate::ID;
<strong>let (address, address_seed) = derive_address(
</strong><strong>                &#x26;custom_seeds,
</strong><strong>                &#x26;address_merkle_tree_pubkey,
</strong><strong>                &#x26;program_id, 
</strong><strong>            );
</strong></code></pre>

**Parameters:**

* `&custom_seeds`: Array with program `SEED` and signer pubkey. Client must use identical seeds.
* `&address_merkle_tree_pubkey`: Pubkey of address tree retrieved via `get_tree_pubkey()`. Must match tree selected by client.
* `&program_id`: The program's on-chain address. The client must use same program ID.

The parameters return:

* the final 32-byte `address` where the compressed account will be created, and
* the 32-byte intermediate `address_seed` used in the Light System program CPI via `into_new_address_params_packed()` below.
{% endstep %}

{% step %}
### Initialize Compressed Account

Initialize the compressed account data structure using the derived address from [Step 5](page-1.md#derive-address).

```rust
let owner = crate::ID;
let mut data_account = LightAccount::<'_, DataAccount>::new_init(
        &owner,
        Some(address), // derived with derive_address
        output_state_tree_index, // configured in create_account instruction
    );
    data_account.owner = ctx.accounts.signer.key();
    data_account.message = message; // different from &owner

```

**Parameters for `LightAccount`:**

* `&owner`: Program ID (`crate::ID`) to set account owner for Light System program.
* `Some(address)`: The derived address from [_Step 5_](page-1.md#derive-address) _Derive Address_, where the compressed account will be created.
* `output_state_tree_index` to specify which state tree will store the compressed account hash and its index, defined in  [_Step 4_](page-1.md#instruction-data-for-create_compressed_account) _Instruction Data for `create_compressed_account`_.

**Field assignments:**

* `data_account.owner`: Sets the transaction signer as the account's data owner, e.g. the user, different from `&owner` above.
* `data_account.message`: Populates the custom data field defined in `DataAccount` struct.
{% endstep %}

{% step %}
### CPI

Invoke the Light System program to create the compressed account using

1. `proof` from [_Step 4_](page-1.md#instruction-data-for-create_compressed_account) _Instruction Data for `create_compressed_account`_,
2. `data_account` from [_Step 6_](page-1.md#initialize-compressed-account) _Initialize Compressed Account_, and
3. `address_seed` from [_Step 5_](page-1.md#derive-address) _Derive Address_.

```rust
let light_cpi_accounts = CpiAccounts::new(
    ctx.accounts.fee_payer.as_ref(),
    ctx.remaining_accounts, // included in getValidityProof() by client
    LIGHT_CPI_SIGNER,
);

let cpi_inputs = CpiInputs::new_with_address(
    proof,
    vec![data_account.to_account_info()?],
    vec![address_tree_info.into_new_address_params_packed(address_seed)],
);

cpi_inputs.invoke_light_system_program(light_cpi_accounts)?;
```

**Parameters for `CpiAccounts::new()`:**

* `ctx.accounts.fee_payer.as_ref()`: Fee payer and signer
* `ctx.remaining_accounts`: Account slice [containing Light System program and merkle tree accounts](#user-content-fn-2)[^2]. Generated via client's `getValidityProof()` RPC call.
* `LIGHT_CPI_SIGNER`: Program signer derived at compile time via `derive_light_cpi_signer!()` macro

**Parameters for `CpiInputs::new_with_address()`:**

* `proof`: Zero-knowledge proof from instruction input to validate address non-inclusion.
* `vec![data_account.to_account_info()?]`: Compressed account information from `LightAccount` wrapper.
* `vec![address_tree_info.into_new_address_params_packed(address_seed)]`: Address registration parameters using address\_seed from `derive_address()`.
{% endstep %}

{% step %}
### That's it!

Now that you understand the concepts to create a compressed account, start building with the create account example below.
{% endstep %}
{% endstepper %}

### Create Account Example

Make sure you have your [developer environment](https://www.zkcompression.com/compressed-pdas/create-a-program-with-compressed-pdas#start-building) set up first.

```bash
npm -g i @lightprotocol/zk-compression-cli
light init testprogram
```

{% hint style="success" %}
Find the [source code](https://github.com/Lightprotocol/program-examples/tree/main/create-and-update) here.
{% endhint %}

{% tabs %}
{% tab title="Anchor" %}
{% hint style="info" %}
`declare_id!` and `#[program]` follow [standard anchor](https://www.anchor-lang.com/docs/basics/program-structure) patterns.
{% endhint %}

```rust
#![allow(unexpected_cfgs)]

use anchor_lang::prelude::*;
use borsh::{BorshDeserialize, BorshSerialize};
use light_sdk::{
    account::LightAccount,
    address::v1::derive_address,
    cpi::{CpiAccounts, CpiInputs, CpiSigner},
    derive_light_cpi_signer,
    instruction::{PackedAddressTreeInfo, ValidityProof},
    LightDiscriminator, LightHasher,
};

declare_id!("HNqStLMpNuNJqhBF1FbGTKHEFbBLJmq8RdJJmZKWz6jH");

pub const LIGHT_CPI_SIGNER: CpiSigner =
    derive_light_cpi_signer!("HNqStLMpNuNJqhBF1FbGTKHEFbBLJmq8RdJJmZKWz6jH");

pub const SEED: &[u8] = b"your_seed";

#[derive(Clone, Debug, Default, BorshSerialize, BorshDeserialize, LightHasher, LightDiscriminator)]
pub struct DataAccount {
    #[hash]
    pub owner: Pubkey,
    #[hash]
    pub message: String,
}

#[program]
pub mod create_compressed_account {
    use super::*;

    pub fn create_compressed_account<'info>(
        ctx: Context<'_, '_, '_, 'info, CreateCompressedAccount<'info>>,
        proof: ValidityProof,
        address_tree_info: PackedAddressTreeInfo,
        output_state_tree_index: u8,
        message: String,
    ) -> Result<()> {
        let light_cpi_accounts = CpiAccounts::new(
            ctx.accounts.signer.as_ref(),
            ctx.remaining_accounts,
            LIGHT_CPI_SIGNER,
        );

        let (address, address_seed) = derive_address(
            &[SEED, ctx.accounts.signer.key().as_ref()],
            &address_tree_info.get_tree_pubkey(&light_cpi_accounts)?,
            &crate::ID,
        );

        let mut data_account = LightAccount::<'_, DataAccount>::new_init(
            &crate::ID,
            Some(address),
            output_state_tree_index,
        );
        data_account.owner = ctx.accounts.signer.key();
        data_account.message = message;

        let cpi_inputs = CpiInputs::new_with_address(
            proof,
            vec![data_account.to_account_info()?],
            vec![address_tree_info.into_new_address_params_packed(address_seed)],
        );

        cpi_inputs.invoke_light_system_program(light_cpi_accounts)?;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateCompressedAccount<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
}
```
{% endtab %}

{% tab title="Native" %}

{% endtab %}

{% tab title="Pinchocchio" %}

{% endtab %}
{% endtabs %}

### Next steps

Learn how to Call Your Program from a Client Learn how to Update Compressed Accounts Learn how to Close Compressed Accounts

[^1]: Instruction:

    * `ValidityProof` for the new address
    * `PackedAddressTreeInfo` containing tree metadata
    * `output_tree_index` specifying which state tree to use
    * Account data to store

[^2]: 1. Light System Program - SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7
    2. CPI Authority - Program-derived authority PDA
    3. Registered Program PDA - Registration account for your program
    4. Noop Program - For transaction logging
    5. Account Compression Authority - Authority for merkle tree operations
    6. Account Compression Program - SPL Account Compression program
    7. Invoking Program - Your program's address
    8. System Program - Standard Solana System program
